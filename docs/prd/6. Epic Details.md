6. Epic Details

6.1 Epic 1: Foundation & Core Grid Injection

Expanded Goal: Establish a functional Chrome Extension architecture (Manifest V3), implement the mechanism for discovering and selecting target DOM elements, and display a 14px grid overlay (CSS/SVG) accurately pinned to the element without blocking user interaction.

6.1.1 Story 1.1: Project Scaffolding & Manifest V3 Setup

User Story: As a Developer, I want a functional extension build system using Vite and Manifest V3 so that I can develop the extension according to modern standards.

Acceptance Criteria:

npm run build command generates a dist folder containing a valid manifest.json (V3) and bundled JS files for background and content scripts.

The extension loads into Chrome Developer Mode (Load Unpacked) without errors.

The extension has a simple Popup or Toolbar Icon that functions.

Content Script runs on any web page and logs "WP Inspector Ready" to the console.

6.1.2 Story 1.2: Element Discovery & Highlighting

User Story: As a User, I want to see a highlight effect when hovering over page elements so that I know exactly which element will be selected for the grid.

Acceptance Criteria:

Hovering over a DOM element displays a Blue Outline around it.

Moving the mouse away removes the blue outline.

Performance must be smooth without lag when moving quickly over nested elements (requires throttling/debouncing or requestAnimationFrame).

Only visible elements with real dimensions are highlighted (ignore hidden or 0x0 px elements).

6.1.3 Story 1.3: Grid Overlay Injection (The "Lock")

User Story: As a User, I want to click on a highlighted element to "pin" (lock) the 14px grid to it so that I can inspect alignment.

Acceptance Criteria:

A click event on a highlighted element triggers grid generation.

The grid is rendered inside a Shadow DOM host attached to (or overlaying) the target element to ensure style isolation.

The Grid Pattern consists of 14px x 14px squares.

The Grid Origin (0,0) must align exactly with the top-left corner of the target element's Padding Box.

If another grid is already visible elsewhere, it must be removed before the new grid appears (Single Instance Rule).

6.1.4 Story 1.4: Click-Through Transparency

User Story: As a Developer, I want to be able to click and interact with elements beneath the grid layer so that my workflow is not interrupted.

Acceptance Criteria:

The container holding the grid must have the CSS property pointer-events: none.

Users can click buttons, links, or form inputs located beneath the grid.

Users can select text located beneath the grid.

Users can right-click to open the Chrome Context Menu on elements beneath the grid (Inspect Element).

6.2 Epic 2: Core Stabilization & Launch Prep

Expanded Goal: Optimize application performance, handle edge cases, and finalize necessary assets for the final product packaging to ensure a stable v1.0 launch.

6.2.1 Story 2.1: Performance Optimization & Polish

User Story: As a User, I want the tool to operate smoothly even when I scroll the page or resize the window, without consuming excessive browser RAM.

Acceptance Criteria:

Use requestAnimationFrame for all mousemove events (throttling).

Handle scroll and resize events: The grid and measurement area must maintain correct positioning relative to the target element (or automatically recalculate position).

Cleanup: Ensure all Event Listeners are removed when the Extension is disabled or switched to another element to avoid Memory Leaks.

6.2.2 Story 2.2: Packaging & Assets Preparation

User Story: As a Product Owner, I want a complete set of installation files and image assets so that I can upload to the Chrome Web Store or distribute to testers.

Acceptance Criteria:

Complete set of standard Icon sizes (16, 32, 48, 128px).

Complete manifest.json file with metadata (name, description, version).

npm run package command (or equivalent) generates a .zip file containing the optimized production build (minified code).

6.3 Epic 3: Configuration & Workflow Optimization

Expanded Goal: Enhance user workflow with global shortcuts and provide a UI for customizing grid settings (size, color) with persistence.

6.3.1 Story 3.1: Global Toggle Shortcut

User Story: As a User, I want to be able to toggle the grid on/off using a keyboard shortcut so that I can quickly check alignment without moving my mouse to the toolbar.

Acceptance Criteria:

Define a default shortcut (e.g., Ctrl+Shift+G or Command+Shift+G).

The shortcut toggles the active state of the extension (same behavior as clicking the icon).

Ensure the shortcut does not conflict with common browser shortcuts.

6.3.2 Story 3.2: Custom Grid Settings UI & Persistence

User Story: As a User, I want to customize the grid size and color via a popup UI and have these settings saved so that I can use the tool on different projects with different requirements.

Acceptance Criteria:

Create a Popup UI (popup.html) with inputs for:
- Grid Size (px) - Default: 14
- Grid Color (Color Picker or Hex Input) - Default: Cyan/Magenta

Save settings using chrome.storage.sync (or local) so they persist across sessions.

The Content Script must listen for storage changes and update the grid immediately (or on next activation).